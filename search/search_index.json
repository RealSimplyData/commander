{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Commander is an open sourced administration panel meant to be used in Roblox experiences, to provide a much intuitive and easygoing way to do game moderation. Created by programmers and artists around the world with love. Version Two \u00b6 This documentation only applies to version two, which is currently under development, for those who are looking for version one, head to this site . License \u00b6 Commander is licensed under the MIT license.","title":"Home"},{"location":"#home","text":"Commander is an open sourced administration panel meant to be used in Roblox experiences, to provide a much intuitive and easygoing way to do game moderation. Created by programmers and artists around the world with love.","title":"Home"},{"location":"#version-two","text":"This documentation only applies to version two, which is currently under development, for those who are looking for version one, head to this site .","title":"Version Two"},{"location":"#license","text":"Commander is licensed under the MIT license.","title":"License"},{"location":"roadmap/","text":"V2 Roadmap \u00b6 We are shifting our focus to the upcoming version of Commander, which is V2. This page contains a list of features/tasks being worked on, so you can catch up with the progress. Name Description Status Assignee Remote listener Add a listener to remote function and remote events \u2705 @7kayoh Base remote listeners Add basic listeners such as commands \u23f3 No one Remote listener extensions Add support for plugins to extend the remote listener for other methods \u2705 @7kayoh API Add more API methods \u23f3 No one DataStores Set up Profiles for Commander user configurations \u23f3 No one BanUtil Finish the banning/unbanning mechanism for both local and global ban, and set up the Profiles for global banning \u23f3 No one Built-in commands Create a few built-in commands for Commander \u23f3 No one Frontend recode Completely rewrite the frontend with the osm framework \u23f3 No one Frontend extensions Add support for plugins to extend the UI for extra functionalities \u23f3 No one","title":"V2 Roadmap"},{"location":"roadmap/#v2-roadmap","text":"We are shifting our focus to the upcoming version of Commander, which is V2. This page contains a list of features/tasks being worked on, so you can catch up with the progress. Name Description Status Assignee Remote listener Add a listener to remote function and remote events \u2705 @7kayoh Base remote listeners Add basic listeners such as commands \u23f3 No one Remote listener extensions Add support for plugins to extend the remote listener for other methods \u2705 @7kayoh API Add more API methods \u23f3 No one DataStores Set up Profiles for Commander user configurations \u23f3 No one BanUtil Finish the banning/unbanning mechanism for both local and global ban, and set up the Profiles for global banning \u23f3 No one Built-in commands Create a few built-in commands for Commander \u23f3 No one Frontend recode Completely rewrite the frontend with the osm framework \u23f3 No one Frontend extensions Add support for plugins to extend the UI for extra functionalities \u23f3 No one","title":"V2 Roadmap"},{"location":"manual/api/","text":"API \u00b6 The API is a collection of reusable functions that helps to reduce the size of a package, or for developers to communicate with Commander externally. As the API is exposed to the server context, please be aware of backdoors, as they may have codes to intervene Commander. Use-cases \u00b6 The API offers opportunities for developers to create lightweight, safe and stable packages for Commander without putting too much focus on compatability. Here are the reasons why you should consider using the API instead of reinventing the wheels: Maintained by the official developers The API is always up-to-date with the entire codebase and has been seriously tested before release, it is by far the most optimal way to create scalable packages. Code safety All code found in the API is coded with caution, the chances of it breaking out of random is rare and physically impossible to happen. Saves line With the use of the API, you can easily make your package extremely lightweight, as majority of the code has been replaced by API methods instead. Methods \u00b6 Players \u00b6 API.checkUserAdmin \u00b6 boolean API.checkuserAdmin( player Player) Returns the administrator status of the user, API.getAdminStatusWithUserId \u00b6 number, string API.getAdminStatusWithUserId( integer UserId) Returns the administration group index and name of the player is in. This method is for when the player is not ingame. API.getAdminLevel \u00b6 number, string API.getAdminLevel( player Player) Returns the administration group index and name of the player is in. API.initializePlayer \u00b6 nil API.initializePlayer( player Player) Initializes the player, this is not needed as Commander already calls this to every player by default. API.wrapPlayer \u00b6 table API.wrapPlayer( player Player) Returns a wrapper of the player. By default, the wrapper contains the following elements: { [ \"Name\" ] = Player . Name , [ \"DisplayName\" ] = Player . DisplayName , [ \"UserId\" ] = Player . UserId , [ \"Character\" ] = Player . Character , [ \"IsAdmin\" ] = API . checkUserAdmin ( Player ), [ \"_instance\" ] = Player } API.getProfile \u00b6 profile API.getProfile( string|integer user) :hourglass-flowing-sand: Asynchronous operation Returns the profile of the user Release the profile once you are done working with it, for more details, refer to the documentation for ProfileService Misc \u00b6 API.addChecker \u00b6 nil API.addChecker( string Name, function Checker) Loads in a checker given in the function call, will be called when a player joins. API.extendPlayerWrapper \u00b6 nil API.extendPlayerWrapper( function Extender) Loads in an extender given in the function call, will be called when .wrapPlayer is requested. API.Initialize \u00b6 nil API.Initialize( Folder remotesFolder) Avoid touching this part, this is meant to be used internally. API.addRemoteTask \u00b6 table API.addRemoteTask( string remoteType, function|string qualifier, function handler) Adds a new task to the corresponding, useful when you want to listen RemoteFunction/Event requests. Accepted remoteTypes: \"Function\" , \"Event\" Returns a table, for you to remove the task once you no longer want to listen: local task = API . addRemoteTask ( \"Function\" , \"onRequest\" , function ( player , requestType , ...) return true end ) task . leave () -- leaves When a handler is being fired, you are expected to receive the player wrapper, the request type, and the arguments.","title":"API"},{"location":"manual/api/#api","text":"The API is a collection of reusable functions that helps to reduce the size of a package, or for developers to communicate with Commander externally. As the API is exposed to the server context, please be aware of backdoors, as they may have codes to intervene Commander.","title":"API"},{"location":"manual/api/#use-cases","text":"The API offers opportunities for developers to create lightweight, safe and stable packages for Commander without putting too much focus on compatability. Here are the reasons why you should consider using the API instead of reinventing the wheels: Maintained by the official developers The API is always up-to-date with the entire codebase and has been seriously tested before release, it is by far the most optimal way to create scalable packages. Code safety All code found in the API is coded with caution, the chances of it breaking out of random is rare and physically impossible to happen. Saves line With the use of the API, you can easily make your package extremely lightweight, as majority of the code has been replaced by API methods instead.","title":"Use-cases"},{"location":"manual/api/#methods","text":"","title":"Methods"},{"location":"manual/api/#players","text":"","title":"Players"},{"location":"manual/api/#apicheckuseradmin","text":"boolean API.checkuserAdmin( player Player) Returns the administrator status of the user,","title":"API.checkUserAdmin"},{"location":"manual/api/#apigetadminstatuswithuserid","text":"number, string API.getAdminStatusWithUserId( integer UserId) Returns the administration group index and name of the player is in. This method is for when the player is not ingame.","title":"API.getAdminStatusWithUserId"},{"location":"manual/api/#apigetadminlevel","text":"number, string API.getAdminLevel( player Player) Returns the administration group index and name of the player is in.","title":"API.getAdminLevel"},{"location":"manual/api/#apiinitializeplayer","text":"nil API.initializePlayer( player Player) Initializes the player, this is not needed as Commander already calls this to every player by default.","title":"API.initializePlayer"},{"location":"manual/api/#apiwrapplayer","text":"table API.wrapPlayer( player Player) Returns a wrapper of the player. By default, the wrapper contains the following elements: { [ \"Name\" ] = Player . Name , [ \"DisplayName\" ] = Player . DisplayName , [ \"UserId\" ] = Player . UserId , [ \"Character\" ] = Player . Character , [ \"IsAdmin\" ] = API . checkUserAdmin ( Player ), [ \"_instance\" ] = Player }","title":"API.wrapPlayer"},{"location":"manual/api/#apigetprofile","text":"profile API.getProfile( string|integer user) :hourglass-flowing-sand: Asynchronous operation Returns the profile of the user Release the profile once you are done working with it, for more details, refer to the documentation for ProfileService","title":"API.getProfile"},{"location":"manual/api/#misc","text":"","title":"Misc"},{"location":"manual/api/#apiaddchecker","text":"nil API.addChecker( string Name, function Checker) Loads in a checker given in the function call, will be called when a player joins.","title":"API.addChecker"},{"location":"manual/api/#apiextendplayerwrapper","text":"nil API.extendPlayerWrapper( function Extender) Loads in an extender given in the function call, will be called when .wrapPlayer is requested.","title":"API.extendPlayerWrapper"},{"location":"manual/api/#apiinitialize","text":"nil API.Initialize( Folder remotesFolder) Avoid touching this part, this is meant to be used internally.","title":"API.Initialize"},{"location":"manual/api/#apiaddremotetask","text":"table API.addRemoteTask( string remoteType, function|string qualifier, function handler) Adds a new task to the corresponding, useful when you want to listen RemoteFunction/Event requests. Accepted remoteTypes: \"Function\" , \"Event\" Returns a table, for you to remove the task once you no longer want to listen: local task = API . addRemoteTask ( \"Function\" , \"onRequest\" , function ( player , requestType , ...) return true end ) task . leave () -- leaves When a handler is being fired, you are expected to receive the player wrapper, the request type, and the arguments.","title":"API.addRemoteTask"},{"location":"manual/packages/","text":"Packages \u00b6 Packages are a new feature that allows you to extend or create features for Commander without modifying the internal source code. They can be used as a command , a plugin , or a stylesheet . In this page, we will walk you through the basics of the Commander package system, and the package manager. Introduction \u00b6 Previously in V1, packages are basically commands in a nutshell, simple as that. The use of the term package was soemwhat redudant due to its sole usage is as a command only. As a result, we have redefined the definition of packages in V2. In V2, a package can be a command, a plugin, or a stylsheet. For plugin, it is not neccessary to return anything, it could be just a run-once code to extend or add features. Or modifies a specific module for greater performance or anything else. Standard template \u00b6 local package = { Name = \"Name\" , Description = \"Description\" , Author = \"User\" , Class = \"Command/Plugin/Stylesheet\" , Target = {} } function package . Target : Init () end return package package.Target:Init() is available for plugins, they will be called after initalization if it existed. Examples \u00b6 API Checker plugin A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all.","title":"Packages"},{"location":"manual/packages/#packages","text":"Packages are a new feature that allows you to extend or create features for Commander without modifying the internal source code. They can be used as a command , a plugin , or a stylesheet . In this page, we will walk you through the basics of the Commander package system, and the package manager.","title":"Packages"},{"location":"manual/packages/#introduction","text":"Previously in V1, packages are basically commands in a nutshell, simple as that. The use of the term package was soemwhat redudant due to its sole usage is as a command only. As a result, we have redefined the definition of packages in V2. In V2, a package can be a command, a plugin, or a stylsheet. For plugin, it is not neccessary to return anything, it could be just a run-once code to extend or add features. Or modifies a specific module for greater performance or anything else.","title":"Introduction"},{"location":"manual/packages/#standard-template","text":"local package = { Name = \"Name\" , Description = \"Description\" , Author = \"User\" , Class = \"Command/Plugin/Stylesheet\" , Target = {} } function package . Target : Init () end return package package.Target:Init() is available for plugins, they will be called after initalization if it existed.","title":"Standard template"},{"location":"manual/packages/#examples","text":"API Checker plugin A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all.","title":"Examples"},{"location":"manual/plugins/","text":"Plugins \u00b6 In V2, we have introduced a brand new package system with a new package type called Plugin , which is used to extend existing features or add new features to Commander. Those can be UI plugins, API plugins, or plugins used by commands. In this page, we will walk you through the process of creating a plugin for Commander. Preparations \u00b6 Before building, we need: A proper installation of Commander 2.x.x Roblox Studio Rojo & External Code Editor (Optional) Start \u00b6 To make a plugin recognizable by Commander, you need to ensure the source file has the proper format and declares itself as a Plugin package. So, copy and paste the standard package format, which can be found here or in the page about packages in general. local package = { Name = \"Plugin\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package It is also recommended to add the above code as a code snippet for future use. For plugins, Commander will call :Init() once all loading for packages has been complete, this includes injecting the necessary dependencies. If your plugin have to require dependencies found in the Core folder, but not in the Preloaded folder, it is a better idea to initialize those dependencies within the :Init() function, and assign them into the package.Target table. A plugin is not necessary to expose methods, a plugin can be a piece of run-once code. Plugins are injected automatically into the commands only, if you are attempting to adjust the API inside a plugin, it is best to look at the API documentation to see is there a suitable API method. Using injected dependencies \u00b6 Commander by default injects 4 dependencies into a plugin -- Core , API , Util , and Settings . However, it is worth noting that the Settings dependency is a copied table, changes to it will not be reflected in the actual settings module. To begin using either one of the dependencies, use the line package.Dependency , where Dependency is the name of the dependency, and package is the package table (Not to be confused with the package target table). Examples \u00b6 API Checker A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all.","title":"Plugins"},{"location":"manual/plugins/#plugins","text":"In V2, we have introduced a brand new package system with a new package type called Plugin , which is used to extend existing features or add new features to Commander. Those can be UI plugins, API plugins, or plugins used by commands. In this page, we will walk you through the process of creating a plugin for Commander.","title":"Plugins"},{"location":"manual/plugins/#preparations","text":"Before building, we need: A proper installation of Commander 2.x.x Roblox Studio Rojo & External Code Editor (Optional)","title":"Preparations"},{"location":"manual/plugins/#start","text":"To make a plugin recognizable by Commander, you need to ensure the source file has the proper format and declares itself as a Plugin package. So, copy and paste the standard package format, which can be found here or in the page about packages in general. local package = { Name = \"Plugin\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package It is also recommended to add the above code as a code snippet for future use. For plugins, Commander will call :Init() once all loading for packages has been complete, this includes injecting the necessary dependencies. If your plugin have to require dependencies found in the Core folder, but not in the Preloaded folder, it is a better idea to initialize those dependencies within the :Init() function, and assign them into the package.Target table. A plugin is not necessary to expose methods, a plugin can be a piece of run-once code. Plugins are injected automatically into the commands only, if you are attempting to adjust the API inside a plugin, it is best to look at the API documentation to see is there a suitable API method.","title":"Start"},{"location":"manual/plugins/#using-injected-dependencies","text":"Commander by default injects 4 dependencies into a plugin -- Core , API , Util , and Settings . However, it is worth noting that the Settings dependency is a copied table, changes to it will not be reflected in the actual settings module. To begin using either one of the dependencies, use the line package.Dependency , where Dependency is the name of the dependency, and package is the package table (Not to be confused with the package target table).","title":"Using injected dependencies"},{"location":"manual/plugins/#examples","text":"API Checker A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all.","title":"Examples"}]}